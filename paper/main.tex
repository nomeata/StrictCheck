% !!! PLEASE DON'T CHANGE THESE !!! INSTEAD DEFINE YOUR OWN texdirectives.tex !!!
% These flags are for the final camera ready version for POPL
% Draft, full version flags
\newif\ifdraft\drafttrue
\newif\iffull\fullfalse
\newif\ifanon\anonfalse
\newif\iflast\lasttrue

% !!! PLEASE DON'T CHANGE THESE !!! INSTEAD DEFINE YOUR OWN texdirectives.tex !!!
\makeatletter \@input{texdirectives} \makeatother

\documentclass[acmsmall,review]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{xspace}
\usepackage{preamble}
\usepackage{relsize}
%\usepackage{mathpartir}

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
% \setcopyright{rightsretained}
% \acmJournal{PACMPL}
% \acmYear{2018} \copyrightyear{2018} \acmVolume{2} \acmNumber{POPL} \acmArticle{45} \acmMonth{1} \acmPrice{}\acmDOI{10.1145/3158133}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\def\l{l}

\begin{document}

%% Title information
\title{Keep your Laziness in Check}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Kenneth Foner}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{USA}
}
\email{kfoner@seas.upenn.edu}          %% \email is recommended

%% Author with single affiliation.
\author{Hengchu Zhang}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{USA}
}
\email{hengchu@seas.upenn.edu}          %% \email is recommended

%% Author with single affiliation.
\author{Leonidas Lampropoulos}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{USA}
}
\email{llamp@seas.upenn.edu}          %% \email is recommended

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
StrictCheck.

Because LazyCheck was taken.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Random Testing, Laziness, Haskell}  %% \keywords is optional

%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

% \lk{
% \begin{description}
%   \item[slant] \the\fontdimen1\font
%   \item[interword space] \the\fontdimen2\font
%   \item[interword stretch] \the\fontdimen3\font
%   \item[interword shrink] \the\fontdimen4\font
%   \item[extra space] \the\fontdimen7\font
%   \item[xspaceskip] \the\xspaceskip
%   \item[hyphenchar] \the\hyphenchar\font
% \end{description}
% }

\section{Introduction}
\label{sec:intro}

%\hzh{Rewrite the intro using different running examples, foldl vs foldr on stream manipulations?}
%\hzh{We can write a hand-crafted spec for take, can we show that we can create this spec by composing the spec for foldr (but not using the one with foldl)}
%\hzh{implement take in 3 ways: foldl, foldr and explicitly as the opening example, and then ask if they're equivalent? (they're not!)}
\hzh{Okasaki has 2 functions that appends a list to the reversal of another list, one of which is too strict and the other one is just the right amount of lazy (thus incremental)}
\hzh{The amortized one is hard to specify exactly, but we can introduce approximate specification and specify it approximately}
\hzh{we need to carefully avoid saying this is a tool for specifying the time complexity of functions}
\hzh{Implementing functional programs that make clever use of laziness is very easy to get wrong, and we provide a solution to make sure the programmer got it right. We almost have no way of testing it right now before StrictCheck.}
\hzh{Email Ryan Trinkle and Dan Winograd-Cort about FRP and strictness, and try to use their examples as another problem we can solve in the intro}
\hzh{Maps will mess up memoization if you're overly strict, use knapsack as an example}

\leo{Point of first paragraph: lazy evaluation is powerful}

Lazy evaluation gives tremendous power to functional programmers
~\cite{WhyFPMatters} and is actively used in various practical
applications. For instance, the big-data framework Spark uses laziness
to drive computations on demand\cn, Apple's programming language Swift
leverages it to initialize expensive resources as needed\cn, and many
functional reactive programming web frameworks crucially rely on
it\cn \leo{This point might need more exposition about frp}. Haskell
is the most popular programming language that allows programmers to
enjoy the power of lazy evaluation by default. However, that power
does not come without a price: reasoning about lazy programs is
notoriously hard. Let us consider two examples that demonstrate the
power of laziness, as well as the intricacies of programming with it.

\leo{Example 1: Okasaki queues}

\leo{The singular feels weird here. Is it just me?}
Purely functional queue is a very popular data structure in
Haskell. Programmers typically implement such queues with two
lists---a front list holding the queue elements in FIFO order, and a
back list holding the other elments in reversed order. When the front
list is empty, a dequeue operation requires a reversal of the back
list to refill the front list. These specific dequeue operations take
$O(n)$ time to finish, and are much slower than their imperative
counterparts. This occasional performance degradation is compounded by
persistence (where the $O(n)$ operation could be repeated many times),
and can be unacceptable in real-time systems.

However, Okasaki cleverly improved upon this design using lazy lists
that both incrementally performs the reversal of the back list, and
incrementally appends the reversal of the back list onto the front
list ~\cite{Okasaki95simpleand}. Okasaki's queue relies on the
following \lk{rotate} function to incrementally reverse and append the
back list.
\begin{inlinecode}
rotate []    back acc = (head back)  : acc
rotate front back acc = (head front) : rest
  where rest = rotate (tail front) (tail back) ((head back) : acc)
\end{inlinecode}
If we computed the expression \lk{rotate front back []}, its value
will be equivalent to \lk{front ++ (reverse back)}. However, the
function \lk{rotate} is much lazier than the naive reverse and append
operation. The function \lk{reverse} has to evaluate the entire
structure of the back list, which is not incremental. On the other
hand, the function \lk{rotate} produces a list immediately, and packs
the rest of the computation into the lazy list \lk{rest}.

Since \lk{rotate} is functionally equivalent to \lk{front ++ (reverse
back)}, a programmer could have implemented it naively and never
discover the mistake through traditional testing! The two only differ
in their laziness behavior, and there is no way of specifying such
subtle differences in any testing frameworks today.

\leo{Example 2: Knapsack}

Laziness also shines in solutions to dynamic programming problems. Let
us consider a solution to the famous knapsack problem that levareges
laziness.

The inputs of the knapsack problem are two sequences of numbers $w_i$
and $v_i$ where $i = 1, \dots, n$, and each of $w_i$ and $v_i$ specify
the weight and the value of the $i$th item. The solution presents the
maximum value achievable using a subset of the items such that their
combined weight is under a limit $W$.

The usual dynamic programming approach for knapsack maintains a
table $OPT[][]$, where the entry $OPT[j][k]$ keeps the best value
achievable using only items $1\dots j$ and a weight limit of $k$. The
table satisfies the following recurrence relation: $$OPT[j][k]
= \max(OPT[j-1][w], w_j + OPT[j-1][k-w_j])$$

To efficiently compute this table using imperative langauges, we look
for shared sub-problems of the original problem, and design a path
along the solution table that maximizes sharing while filling out the
answers.
%
However, lazy evaluation automatically finds this path if we
use \lk{Data.Map.Lazy} and setup the solution table with the
recurrence relation \hzh{We can probably make this code prettier}
\begin{inlinecode}
ws, vs :: [Int]
n,  w  :: Int

solution :: Map (Int, Int) Int
solution = fromList [ ((j, k),
                       if (j-1) < 0 || k - ws !! j < 0
                       then 0
                       else max (solution ! (j-1, k))
                                (solution ! (j-1, k - ws !! j) + vs !! j)
                      )
                    | j <- [0..n-1], k <- [0..w] ]
\end{inlinecode}

Using the lazy variant of \lk{Map} here is critical for the correctness
of \lk{solution}. If we used \lk{Data.Map.Strict} instead, then \lk{fromList}
would have eagerly evaluated the \lk{if} expression. The \lk{if} expression
contains value-level recursion to itself, and this would manifest as an infinite
loop at runtime. This is an incredibly subtle bug related to laziness.

As these examples show, the power of laziness puts great
responsibility on programmers' shoulders. An incorrect implementation
can either behave functionally the same but with inferior performance,
or it can completely break down! Reasoning about lazy programs is also
notoriously hard because predicting when a lazy value gets evaluated
is difficult.

\leo{Didn't we have an FRP quote by someone that Laziness was the third source of
bugs or something? Work that in?}
\hzh{Ryan Trinkle (author of Reflex) said laziness was the 3rd most difficult thing to
get right, but let's check with him on whether we can quote him on that.}

How, then, can we test and catch these laziness bugs during development? Is it
possible to precisely specify laziness behavior just as we would for functional
correctness?
%
In this paper, we demonstrate techniques for observing laziness in Haskell, and
propose a system of creating specifications of lazy Haskell programs. We
implement these ideas as a Haskell library.

Our technical contributions are as follows:
\begin{itemize}
\item We introduce a novel approach to specifying the laziness behavior of functions that is
{\em precise} \hzh{and compositional}. Such specifications are
expressive enough to capture exactly how much evaluation occurs within
a data structure \leo{Also add drawbacks/partiality here? If not here,
where in the intro?} \hzh{I'm not sure if we should bring in
partiality (in the sense of divergence/nontermination) yet since that
seems like a rather technical detail of the spec}
\item We propose a framework for testing against such specifications.
\item We improve upon the random function generators from QuickCheck to generate functions with arbitrary laziness behaviors.
\item We demonstrate non-trivial generic programming techniques to apply StrictCheck to almost all data types.
\end{itemize}
%
Section~\ref{sec:related} discusses related work. We conclude and draw
directions for future work in Section~\ref{sec:concl}.

\section{Strictness Specifications, by Example}
\label{sec:quickchick}

\leo{Punned names for sections? Or is that just an urns thing? :P }

\begin{itemize}
\item In this section we will showcase our proposed specification language \leo{It's not a language tho}
\item while introducing the running example of our paper: maps.
\item Maps are particularly well-suited for a discussion of laziness because of the interesting different
possible behaviors: strict-maps, value-lazy maps \leo{Point out Data.Map.Strict vs Data.Map}, and fully lazy maps
\item For simplicity, we will use binary search trees as maps, assuming the keys are integers and forego balancing
as the added complexity is irrelevant to the laziness discussion. \leo{Can we claim it wouldn't matter at all? I think so}
\end{itemize}

\paragraph*{Binary Search Trees}

\leo{data structures - code - short explanation}

\paragraph*{Characterizing Laziness}

\begin{itemize}
\item Specification of laziness - TreeD data structure \leo{Mention how it will be generically derived}
\item Strict / Spine-strict maps
\item Fully lazy map as a between spec
\end{itemize}

\section{Evaluation}
\label{sec:eval}

\section{Related Work}
\label{sec:related}

\leo{If we want to break up this into smaller chunks, use paragraph*}

\section{Conclusion and future work}
\label{sec:concl}

Machine Learning for automatically synthesizing specs? Let's go crazy!

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
We are grateful to
%
José Manuel Calderón Trilla,
Matt Parsons,
Stephanie Weirich,
Jennifer Paykin,
Robert Rand,
Antal Spector-Zabusky,
Matthew Weaver,
and the Penn PLClub
for their useful comments.
This material is based upon work supported by the
\grantsponsor{GS100000001}{National Science
  Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
No.~\grantnum{GS100000001}{1421243} ({\em Random Testing for Language
Design}), Grant No.~\grantnum{GS100000001}{1521523} ({\em Expeditions
in Computing: The Science of Deep Specification}), and \leo{Kenny,
Hengchu, ask for grant numbers names} Any opinions, findings, and
conclusions or recommendations expressed in this material are those of
the author and do not necessarily reflect the views of the National
Science Foundation.

\end{acks}

%% Bibliography
%\bibliography{bibfile}
\bibliography{local}


%% Appendix
%\appendix
%\section{Appendix}
%
%Text of appendix \ldots

\end{document}
