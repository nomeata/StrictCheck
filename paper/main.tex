% !!! Please Don't CHANGE THESE !!! INSTEAD DEFINE YOUR OWN texdirectives.tex !!!
% These flags are for the final camera ready version for POPL
% Draft, full version flags
\newif\ifdraft\drafttrue
\newif\iffull\fullfalse
\newif\ifanon\anonfalse
\newif\iflast\lasttrue

% !!! PLEASE DON'T CHANGE THESE !!! INSTEAD DEFINE YOUR OWN texdirectives.tex !!!
\makeatletter \@input{texdirectives} \makeatother

\documentclass[acmsmall,review]{acmart}\settopmatter{}

%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format should change 'acmlarge' to
%% 'sigplan,10pt'.


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{xspace}
\usepackage{preamble}
\usepackage{relsize}
\usepackage{float}
\usepackage{cleveref}
%\usepackage{mathpartir}

\makeatletter\if@ACM@journal\makeatother
%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
% \setcopyright{rightsretained}
% \acmJournal{PACMPL}
% \acmYear{2018} \copyrightyear{2018} \acmVolume{2} \acmNumber{POPL} \acmArticle{45} \acmMonth{1} \acmPrice{}\acmDOI{10.1145/3158133}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2017}           %% If different from \acmYear


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

\def\l{l}

\begin{document}

%% Title information
\title{Keep your Laziness in Check}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
%                                        %% can be repeated if necessary;
%                                        %% contents suppressed with 'anonymous'
%\subtitle{}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Kenneth Foner}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{USA}
}
\email{kfoner@seas.upenn.edu}          %% \email is recommended

%% Author with single affiliation.
\author{Hengchu Zhang}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{USA}
}
\email{hengchu@seas.upenn.edu}          %% \email is recommended

%% Author with single affiliation.
\author{Leonidas Lampropoulos}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position1}
%  \department{Department1}              %% \department is recommended
  \institution{University of Pennsylvania}            %% \institution is required
%  \streetaddress{Street1 Address1}
%  \city{City1}
%  \state{State1}
%  \postcode{Post-Code1}
  \country{USA}
}
\email{llamp@seas.upenn.edu}          %% \email is recommended

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necesary
                                        %% contents suppressed with 'anonymous'


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
StrictCheck.

Because LazyCheck was taken.
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{Random Testing, Laziness, Haskell}  %% \keywords is optional

%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle

% \lk{
% \begin{description}
%   \item[slant] \the\fontdimen1\font
%   \item[interword space] \the\fontdimen2\font
%   \item[interword stretch] \the\fontdimen3\font
%   \item[interword shrink] \the\fontdimen4\font
%   \item[extra space] \the\fontdimen7\font
%   \item[xspaceskip] \the\xspaceskip
%   \item[hyphenchar] \the\hyphenchar\font
% \end{description}
% }

\section{Introduction}
\label{sec:intro}

%\hzh{Rewrite the intro using different running examples, foldl vs foldr on stream manipulations?}
%\hzh{We can write a hand-crafted spec for take, can we show that we can create this spec by composing the spec for foldr (but not using the one with foldl)}
%\hzh{implement take in 3 ways: foldl, foldr and explicitly as the opening example, and then ask if they're equivalent? (they're not!)}
\hzh{Okasaki has 2 functions that appends a list to the reversal of another list, one of which is too strict and the other one is just the right amount of lazy (thus incremental)}
\hzh{The amortized one is hard to specify exactly, but we can introduce approximate specification and specify it approximately}
\hzh{we need to carefully avoid saying this is a tool for specifying the time complexity of functions}
\hzh{Implementing functional programs that make clever use of laziness is very easy to get wrong, and we provide a solution to make sure the programmer got it right. We almost have no way of testing it right now before StrictCheck.}
\hzh{Email Ryan Trinkle and Dan Winograd-Cort about FRP and strictness, and try to use their examples as another problem we can solve in the intro}
\hzh{Maps will mess up memoization if you're overly strict, use knapsack as an example}

\leo{Point of first paragraph: lazy evaluation is powerful}
\caleb{What does the word ``power'' mean? It's non-specific. Useful? Convenient?}

Lazy evaluation gives tremendous  to functional programmers
~\cite{WhyFPMatters} and is actively used in various practical
applications. For instance, the big-data framework Spark uses laziness
to drive computations on demand\cn, Apple's programming language Swift
leverages it to initialize expensive resources as needed\cn, and many
functional reactive programming web frameworks crucially rely on
it\cn \leo{This point might need more exposition about frp}. Haskell
is the most popular programming language that allows programmers to
enjoy the power of lazy evaluation by default. However, that power
does not come without a price.
\leo{Didn't we have an FRP quote by someone that Laziness was the third source of
bugs or something? Work that in?}
\hzh{Ryan Trinkle (author of Reflex) said laziness was the 3rd most difficult thing to
get right, but let's check with him on whether we can quote him on that.}

\caleb{Again, power and responsibility are not completely clear, but I do like the narrative}
The power of laziness puts great responsibility on programmers'
shoulders. An incorrect implementation can either behave functionally
the same but with inferior \caleb{Inferior than what?} performance, or it can completely break
down!\caleb{unclear. loops?} Reasoning about lazy programs is also notoriously hard --- the
programmer needs to have a mental model of the order of evaluation of
the code, and this order is not always obvious from the syntax of the
code.

How, then, can we test and catch these laziness bugs during
development? Is it possible to precisely specify laziness behavior
just as we would for functional correctness?
%
In this paper, we demonstrate techniques for observing laziness in
Haskell, and propose a system of creating specifications of lazy
Haskell programs. We implement these ideas as a Haskell library. For
concreteness, consider the following small example on the
function \lk{take}, which accepts an integer $n$ and a list, and returns
a prefix of the list with length $n$. If $n$ is larger than the length
of the original list, then the entire list is returned.
%
\begin{inlinecode}
take_spec :: Shaped a => Spec '[Int, [a]] [a]
take_spec =
  Spec $ \predict d n xs ->
    predict (nf n) (if n > length xs then E d else endThunk d)
  where
    endThunk :: PosDemand [a] -> Demand [a]
    endThunk = \case
      Nil'        -> T
      dx :% T     -> E (dx :% T)
      dx :% E dxs -> E (dx :% endThunk dxs)
\end{inlinecode}
%
\hzh{TODO: describe what this spec means in English}

In the next section we work through two more examples, functional
queues and functional maps, demonstrating both the difficulties of
programming with laziness and how our approach can be used to
alleviate them.
%
In the rest of the paper, we present our technical contributions:
\begin{itemize}
\item We introduce a novel approach to specifying the laziness behavior
of functions that is {\em precise} and {\em compositional}. Such
specifications are expressive enough to capture exactly how much
evaluation occurs within a data structure
%\leo{Also add
%drawbacks/partiality here? If not here, where in the intro?} \hzh{I'm
%not sure if we should bring in partiality (in the sense of
%divergence/nontermination) yet since that seems like a rather
%technical detail of the spec}
\item We propose a framework for automated testing against such specifications.\caleb{Automated testing? Can be more specific}
\item We improve upon the random function generators from QuickCheck\cn to generate functions with arbitrary laziness behaviors.
\item We discuss our generic programming-based impementation to apply StrictCheck to all algebraic data types.\caleb{I don't know
the meaning of non-trivial and almost-all}
\end{itemize}
%
Section~\ref{sec:related} discusses related work. We conclude and draw
directions for future work in Section~\ref{sec:concl}.

\section{Strictness Specifications, by Example}
\label{sec:quickchick}

For our first example, we turn to a very popular data structure:
purely functional queues.  Such queues are typically implemented with
two lists---a front list holding the queue elements in FIFO order, and
a back list holding the other elments in reversed order. When the
front list is empty, a dequeue operation must reverse the back list to
refill the front list. These specific dequeue operations take $O(n)$
time to finish and are much slower than their imperative
counterparts, a performance degradation only compounded by
persistence---where the $O(n)$ operation could be repeated many times,
and unacceptable for many real-time systems.

Amongst his work on purely functional data structures\cite{Okasaki},
Okasaki cleverly improved upon this design using lazy lists that both
incrementally performs the reversal of the back list, and
incrementally appends the reversal of the back list onto the front
list ~\cite{Okasaki95simpleand}. Okasaki's queue relies on the
following \lk{rotate} function to incrementally reverse and append the
back list.
\begin{inlinecode}
  rotate :: [a] -> [a] -> [a] -> [a]
  rotate      []       []  as =                       as
  rotate      []  (b : bs) as =     rotate [] bs (b : as)
  rotate (f : fs)      []  as = f : rotate fs []      as
  rotate (f : fs) (b : bs) as = f : rotate fs bs (b : as)
\end{inlinecode}
If we computed the expression \lk{rotate front back []}, its value
will be equivalent to \lk{front ++ (reverse back)}. However, unlike
the naive reverse-and-append operation, \lk{rotate} is much
lazier. A \lk{reverse} function has to evaluate the entire structure
of the back list, which is not incremental. On the other
hand, \lk{rotate} produces a list immediately, and packs the rest of
the computation into the lazy list \lk{rest}.

Since \lk{rotate} is functionally equivalent to \lk{front ++ (reverse
back)}, a programmer could have implemented it naively and never
discover the mistake through traditional testing! The two only differ
in their laziness behavior. Fortunately, we can use StrictCheck to
write a specification that makes this property of \lk{rotate}
testable.

To describe the laziness behavior, we need to first introduce a few
types that describe how lists are used. We use the
term \textit{demand} to refer to the shape of such usage. Concretely,
a \textit{demand} is a shape that describes the used part of a data
structure. For lists, \textit{demands} will be prefixes of lists. We
use the type \lk{ListD} to represent such demands.
%
\begin{inlinecode}
  data ListD a = NilD
               | ConsD (Thunk a) (Thunk (ListD a))
\end{inlinecode}
%
The \lk{Thunk} type used in \lk{ListD} has 2 constructors: \lk{E}
for \textit{evaluated} and \lk{T}, a nullary constructor,
for \textit{thunk}. In \lk{ListD}, \lk{Thunk} wraps around all the
list constructor fields, and this allows us to represent lack of
further evaluation by using the \lk{T} constructor. For example, given
the list \lk{[1, 2, 3]}, the value \lk{ConsD T (ConsD T T)} represents
the \textit{demand} that reveals the first 2 \lk{Cons} constructors of
the list, but does not evaluate any other parts of the list. To
improve readability of demand values, we will also use the
syntax \lk{\_ : \_ : \_} where appropriate, the underscore $\lk{\_}$
represents a thunk.

In Haskell, to trigger the evaluation of a lazy function, we need to
exert some demand on the result of that function. This suggests a
natural flow for the specification of a lazy function --- given the
demand on the output, the specification should calculate the demands
on the input. However, this is not enough in general because the
demand on the input could depend on the \textit{value} of the inputs
as well. The \lk{take} function introduced in \Cref{sec:intro} is such
a case since the length of the output from \lk{take} depends on its
integer argument.

Putting these pieces together, we arrive at an appropriate type for
the specification of \lk{rotate}: \lk{ListD a -> [a] -> [a] -> [a] ->
(ListD a, ListD a, ListD a)}.
%
\hzh{The description here needs improvement}
To specify the laziness behavior of \lk{rotate}, we return to Okasaki's insight:
as long as the front list is longer than the back list, demanding the first
element from the result of \lk{rotate} only causes evaluation of the first
element of the front list ~\cite{Okasaki95simpleand}. Using this precondition
for \lk{rotate}, we arrive at the following executable
specification \lk{rotate\_spec}.

Turning our intuition above into a Haskell function, we complete the
specification of \lk{rotate} in \Cref{fig:rotate-spec}
\begin{figure}[H]
\centering
\hzh{TODO}
\begin{inlinecode}
TODO: rewrite this spec so it looks like the invariant in Okasaki's paper.
\end{inlinecode}
\caption{Specification for \lk{rotate}}
\label{fig:rotate-spec}
\end{figure}

\lk{rotate\_spec} exactly captures the core idea from Okasaki's \lk{rotate}
operation, and testing the reverse and append implementation against this
specification immediately produces a counter example. \hzh{should we show what a
counter example looks like?}\leo{Definitely!}

\leo{Example 2: Maps / Knapsack}

For the second example, we turn to a different functional data structure where
both a strict and a lazy variant can be situationally useful: maps. There are
two reasonable laziness behaviors that implement a map interface; we could
implement a completely strict map, or we could lazily evaluate the values stored
as needed.
\footnote{A third option could be to have lazy keys, but they would
necessarily be forced at every insertion or lookup, with no gain.}
Haskell's standard library provides these two variants in the form of
\lk{Data.Map.Strict} and \lk{Data.Map.Lazy}. However, there is no way
to {\em specify} the difference between the two versions! At best, one
could hope for a hand-crafted suite of unit tests containing divergent
terms to observe a difference in termination.
\leo{One thing we could do is ignore the knapsack and expand on the above.}

Moreover, it is important to be able to distinguish whether such a datatype
follows a desired laziness behavior. For instance, the standard functional
solution for dynamic programming problems crucially uses laziness \hzh{is this
solution really standard? Is there some work we can cite to establish this
approach as the canonical approach for dynamic programming in functional
programming?}. Let us consider the famous knapsack problem.
%
The inputs of the problem are two sequences of numbers $w_i$ and $v_i$
where $i = 1, \dots, n$, and each of $w_i$ and $v_i$ specify the
weight and the value of the $i$th item. The solution presents the
maximum value achievable using a subset of the items such that their
combined weight is under a limit $W$.
%
The usual dynamic programming approach for knapsack maintains a
table $OPT[][]$, where the entry $OPT[j][k]$ keeps the best value
achievable using only items $1\dots j$ and a weight limit of $k$. The
table satisfies the following recurrence relation: $$OPT[j][k]
= \max(OPT[j-1][w], w_j + OPT[j-1][k-w_j])$$

To efficiently compute this table using imperative langauges, we look
for shared sub-problems of the original problem, and design a path
along the solution table that maximizes sharing while filling out the
answers.
%
However, in Haskell, we can define a function that computes one step
of the recurrence relation, and take the fixpoint of this function as
the final solution table. Laziness allows us to define such a solution
table without actually computing all of its entries. When an entry is
demanded, laziness again helps us by only evaluating the required
entries, freeing us from having to design an optimal path along the
solution table.
%
\begin{inlinecode}
weights :: [Int]
values  :: [Int]
limit   :: Int

solutionStep :: Map (Int, Int) Int -> Map (Int, Int) Int
solutionStep soln =
  fromList [((j, k), knapsack j k) |
            j <- [0 .. length weights-1], k <- [0 .. limit]]
  where
    knapsack j k = if j - 1 < 0 || k - weights !! j < 0
                   then if weights !! j <= k then values !! j else 0
                   else max (soln ! (j-1, k))
                            (soln ! (j-1, k - weights !! j) + values !! j)

solution :: Map (Int, Int) Int
solution = fix solutionStep

\end{inlinecode}
%
To query the optimal achievable values from the solution table, we can
just index into the map. When an entry from the map is looked up at
the first time, a sequence of evaluations is triggered, and their
results memoized in the lazy map automatically.

Using the lazy variant of \lk{Map} here is critical for the
correctness of \lk{solution}. If we used a map strict in its values
instead, then \lk{fromList} would have eagerly evaluated the \lk{if}
expression. The \lk{if} expression contains value-level recursion to
\lk{solution} itself, and this would manifest as an infinite loop
at runtime. This is an incredibly subtle bug related to laziness.

To catch this behavior through testing, we can write another specification that
captures this correctness condition. The well-foundedness \hzh{is this a word?}
of \lk{solution} depends on what is evaluated when the value at key \lk{(j, k)}
of the map is demanded. Let $\lk{solutionStep}_n$ be the $n$-times iterated
step function \lk{solutionStep . solutionStep . ... . solutionStep}, then if we
demand the value at \lk{(j, k)} from the result of $\lk{solutionStep}_n$, its
input map should not be evaluated at the \lk{(j, k)} entry since otherwise
evaluating the value at \lk{(j, k)} becomes an infinite loop at the fixpoint.

We can write another executable specification for this property
of $\lk{solutionStep}_n$. Testing the implementation based on
strict maps also immediately produces a counter example.
%
\begin{inlinecode}
TODO: expectation-spec for solutionStep
\end{inlinecode}
%

\leo{Punned names for sections? Or is that just an urns thing? :P }

\begin{itemize}
\item In this section we will showcase our proposed specification language \leo{It's not a language tho}
\item while introducing the running example of our paper: maps.
\item Maps are particularly well-suited for a discussion of laziness because of the interesting different
possible behaviors: strict-maps, value-lazy maps \leo{Point out Data.Map.Strict
vs Data.Map}, and fully lazy maps
\item For simplicity, we will use binary search trees as maps, assuming the keys are integers and forego balancing
as the added complexity is irrelevant to the laziness discussion. \leo{Can we claim it wouldn't matter at all? I think so}
\end{itemize}

\paragraph*{Binary Search Trees}

\leo{data structures - code - short explanation}

\paragraph*{Characterizing Laziness}

\begin{itemize}
\item Specification of laziness - TreeD data structure \leo{Mention how it will be generically derived}
\item Strict / Spine-strict maps
\item Fully lazy map as a between spec
\end{itemize}

\section{Evaluation}
\label{sec:eval}

\section{Related Work}
\label{sec:related}

\leo{If we want to break up this into smaller chunks, use paragraph*}

\section{Conclusion and future work}
\label{sec:concl}

Machine Learning for automatically synthesizing specs? Let's go crazy!

%% Acknowledgments
\begin{acks}                            %% acks environment is optional
                                        %% contents suppressed with 'anonymous'
  %% Commands \grantsponsor{<sponsorID>}{<name>}{<url>} and
  %% \grantnum[<url>]{<sponsorID>}{<number>} should be used to
  %% acknowledge financial support and will be used by metadata
  %% extraction tools.
We are grateful to
%
Jos\'e Manuel Calder\'on Trilla,
Matt Parsons,
Stephanie Weirich,
Jennifer Paykin,
Robert Rand,
Antal Spector-Zabusky,
Matthew Weaver,
and the Penn PLClub
for their useful comments.
This material is based upon work supported by the
\grantsponsor{GS100000001}{National Science
  Foundation}{http://dx.doi.org/10.13039/100000001} under Grant
No.~\grantnum{GS100000001}{1421243} ({\em Random Testing for Language
Design}), Grant No.~\grantnum{GS100000001}{1521523} ({\em Expeditions
in Computing: The Science of Deep Specification}), and \leo{Kenny,
Hengchu, ask for grant numbers names} Any opinions, findings, and
conclusions or recommendations expressed in this material are those of
the author and do not necessarily reflect the views of the National
Science Foundation.

\end{acks}

%% Bibliography
%\bibliography{bibfile}
\bibliography{local}


%% Appendix
%\appendix
%\section{Appendix}
%
%Text of appendix \ldots

\end{document}
